ls: List files and directories in the current location.
Example: ls -l (long format listing), ls -a (show hidden files), ls -lh (long format with human-readable file sizes).

cd: Change the current directory.
Example: cd /path/to/directory.

pwd: Print the current working directory.

mkdir: Create a new directory.
Example: mkdir new_folder.

rm: Remove files or directories.
Example: rm file.txt (remove a file), rm -r directory (remove a directory and its contents).

cp: Copy files or directories.
Example: cp file.txt /path/to/destination, cp -r folder /path/to/destination.

mv: Move or rename files or directories.
Example: mv file.txt new_location, mv old_name new_name.

touch: Create an empty file.
Example: touch new_file.txt.

cat: Display the contents of a file.
Example: cat file.txt.

grep: Search for a pattern in files.
Example: grep "pattern" file.txt.

echo: Print text to the terminal.
Example: echo "Hello, world!".

chmod: Change file permissions.
Example: chmod 755 file.sh (give read, write, execute permission to the owner, and read/execute to others).

chown: Change file ownership.
Example: chown newuser:newgroup file.txt.

ps: Display information about running processes.
Example: ps aux (detailed process listing).

top: Display real-time system information and process statistics.

df: Show disk space usage of file systems.
Example: df -h (human-readable sizes).

du: Display disk usage of files and directories.
Example: du -h file.txt (human-readable size).

wget: Download files from the web.
Example: wget https://example.com/file.txt.

tar: Archive and extract files.
Example: tar -cvzf archive.tar.gz files (create a gzipped archive), tar -xvzf archive.tar.gz (extract a gzipped archive).

ssh: Securely connect to a remote server.
Example: ssh username@remote_host.

Remember to use the man command followed by the name of the command (e.g., man ls) to access the manual pages and get more detailed information about each command and its options.

*Install packages
--------------------
yum install vim -y
yum install wget -y
yum install unzip -y
yum install epel-release -y
yum install ansible -y
yum install tree -y
yum install git -y
yum install maven -y
yum install java -y
yum install stress -y
yum install httpd -y
yum install python-pip -y

*Versions
java -version
mvn --version
git --version
python --version
ansible --version

Jenkins instalation steps
-------------------------
sudo yum update –y

sudo wget -O /etc/yum.repos.d/jenkins.repo \
    https://pkg.jenkins.io/redhat-stable/jenkins.repo

sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io-2023.key

sudo yum upgrade

sudo dnf install java-11-amazon-corretto -y

sudo yum install jenkins -y
sudo systemctl enable jenkins
sudo systemctl start jenkins
sudo systemctl status jenkins
 go to jenkins server give( cat /var/lib/jenkins/secrets/initialAdminPassword)

Nexus installation steps
------------------------
yum install java-1.8.0
y enter
yum install wget -y && yum install unzip -y && yum install java -y
wget https://download.sonatype.com/nexus/oss/nexus-2.14.4-03-bundle.zip
unzip nexus-2.14.4-03-bundle.zip
vi nexus-2.14.4-03/bin/nexus (uncomment# then replace RUN_AS_USER=root)
bash nexus-2.14.4-03/bin/nexus restart

tomcat installation steps
-----------------------------
yum install java-1.8*

wget https://downloads.apache.org/tomcat/tomcat-9/v9.0.80/bin/apache-tomcat-9.0.80.tar.gz.asc

tar -xvf apache-tomcat-9.0.80.tar.gz

cd apache-tomcat-9.0.80/bin
cd ..
cd conf

nano server.xml
edit 8082 and save
 Exp(In server.xml, find a statement similar to the following:

<Connector port="8443" maxHttpHeaderSize="8192"
   maxThreads="150" minSpareThreads="25" maxSpareThreads="75"
   enableLookups="false" redirectPort="8080" acceptCount="100"
   connectionTimeout="20000" disableUploadTimeout="true" />
or

<Connector port="8443" protocol="HTTP/1.1"
   connectionTimeout="20000"
   redirectPort="8080" />
Change the Connector port=”8443″ port to any other port number.

For example:

<Connector port="8181" protocol="HTTP/1.1"
   connectionTimeout="20000" 
   redirectPort="8080" />)

cd ..
cd bin


chmod +x startup.sh

chmod +x shutdown.sh

ps -ef | grep tomcat

wget localhost:8082

./startup.sh

find / -name context.xml (edit last 4 files of context.xml commenting value and next line)

vi /opt/apache-tomcat-9.0.78/webapps/manager/META-INF/context.xml (comment value <!-- and -->)

cd..
ls
cd conf
ls
go to  (tomcat-users.xml)command ( vi  tomcat-users.xml)

after this we need to edit tomcat-users.xml 

<role rolename="manager-gui"/>
<role rolename="manager-script"/>
<role rolename="manager-jmx"/>
<role rolename="manager-status"/>
<user username="admin" password="admin" roles="manager-gui,manager-script,manager-jmx,manager-status"/>
<user username="deployer" password="deployer" roles="manager-script"/>
<user username="tomcat" password="s3cret" roles="manager-gui"/>

Run Jenkins in windows
------------------------
1) need to download Java jdk 1st java 11,17,21
I downloaded java jdk 17 and install
2) opn java path go to c/program files/java/jdk17   
Copy this path
3) check in windows environment variables and add a now path using java path
4) download  and install Jenkins and give java path in Jenkins also
5) to cmd check java version ( java- version)
6)  go to Jenkins path and copy Jenkins.war and paste it in java bin paste in that  place
7) opn cmd in that same java path
Start Jenkins by using this. ( java -jar Jenkins.war)
8) opne chrome enter ( localhost:8080) 
It will opn

configurations in our local system using poweshell
--------------------------------------------------
#!/bin/bash

echo "what is your device name?"

read name
user=$(whoami)
date=$(date)
whereami=$(pwd)
internet=$(netstat)
system_info=$(uname -a)
processes=$(ps aux)
disk_usage=$(df -h)
memory_usage=$(free -m)

echo "hello $name"

sleep 3

echo "how is your battary health $name"

sleep 2

echo "how is your cpu health $name"

sleep 2

echo "RAM is overloaded $name"

sleep 2

echo "you are in current $user"

sleep 2

echo "todays $date"

sleep 2

echo "working directory $whereami"

sleep 2

echo "network status $internet"

sleep 2

echo "my system information $system_info"

sleep 2

echo "my process details $processes"

sleep 2

echo "my system disk usage $disk_usage"

sleep 2

echo "my system storage $memory_usage"
Test for view using Bash
------------------------
1)open powershell where your .pem file u have
using powershell
2)connect with your ec2 ip by using id run instance-connect-ssh client-copy that exp(ssh -i "slave.pem" ec2-user@ec2-16-170-254-73.eu-north-1.compute.amazonaws.com)
3)create  file( touch sumanth.sh) bash file
4)write somethg in this file (nano sumanth.sh) opneed file us this (bash sumanth.sh)
( #!/bin/bash  
echo ***
sleep 2
echo ***
echo****
)
save this file using ( ctrl+x - y - enter)
5) give permeion  by using this for exicution( chmod +x sumanth.sh)
6) exicute (./sumanth.sh)
7)for view - bash sumanth.sh
8)for list of files -ls
9)for list of files full data - ls -al
10)for perticulor file - ls -l

Notes for all directories in Root
---------------------------------
Bin: all user commands , and stores all user files(Normal user)
Sbin: (super user) only adminstrator users can access
Boot: boot files like supporting files (loading before running any file)
Dev: device file storage ( lile pendrive , cd, dvd etc)
Etc: system configuration files
Home: home directory path
Lib: 32bit supporting files (library file)
lib 64: 64bit supporting files (library file)
Media&mnt: extra directory just feee directory for mont
Opt: 3rd party software files will save( optional)
Proc: process related files( ram size,cpu,) system inventory files
Root: root user personal files will store
Run: mont files will store and immediate execution perpose
Sev: service provided by the system ( service related information this stores)
Sys: system related files will store ( related support files) hardware
Temp: temporary directly ( every one have this access but on one can delete this) only temporary files u can create and dlt
Usr: location system application information will store
Var:thos Store all services,system running services and full data will store

Linux
-----------------------
Sudo dnf update
Sudo dnf install  docker
Sudo systemctl start docker 
Sudo systemctl enable doctor
Sudo systemctl status docker
Cantrol+c
Doctor info	

ubuntu:-
---------------------------
sudo apt-get update
sudo apt install docker
sudo apt install docker.io
sudo systemctl start docker
sudo systemctl enable docker
sudo systemctl status docker

install docker by using suse system:-
-----------------------------------
sudo zypper refresh
sudo zypper install docker
sudo zypper install docker
sudo systemctl start docker
sudo systemctl enable docker
sudo systemctl status docker
sudo docker --version

install docker by using redhat system:-
--------------------------------------
sudo yum update
sudo yum install epel-release
sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
sudo yum install docker-ce
sudo systemctl start docker
sudo systemctl enable docker
sudo systemctl status docker
sudo docker --version
docker run hello-world

create hello-world in html:-
-----------------------------------------
i am createing ec2 using linux and installing docker after running ubuntu in this

1st install docker
2nd give givelane nano dockerfile and add below matter in that

FROM public.ecr.aws/docker/library/ubuntu:18.04

# Install dependencies
RUN apt-get update && \
 apt-get -y install apache2

# Install apache and write hello world message
RUN echo 'Hello World!' > /var/www/html/index.html

# Configure apache
RUN echo '. /etc/apache2/envvars' > /root/run_apache.sh && \
 echo 'mkdir -p /var/run/apache2' >> /root/run_apache.sh && \
 echo 'mkdir -p /var/lock/apache2' >> /root/run_apache.sh && \
 echo '/usr/sbin/apache2 -D FOREGROUND' >> /root/run_apache.sh && \
 chmod 755 /root/run_apache.sh

EXPOSE 80

CMD /root/run_apache.sh

sudo docker build -t hello-world .
sudo docker images
sudo docker run -t -i -p 80:80 hello-world

go to ec2 change some security create new rull (att trafic 000000)
go to chrome type ( Http://public-id) and enter

remove the docker images and repositories:-
-----------------------------------------
docker system prune
sudo rm -rf /var/lib/docker
sudo apt autoremove --purge snapd

create ec2-instance by using terraform:-
--------------------------------------
Download terraform and aws and rebuild it
Create key
Create s3 bucket
Check this once below commands
Terraform --version
Aws --version 
Aws configure
After that check (aws s3 ls)
Terraform init
Terraform plan
Terraform apply


create 2 multicontainers by using docker in AWS ec2-instance:-
------------------------------------------------------------
*)sudo docker network create todo-app
*)sudo docker run -d \
    --network todo-app --network-alias mysql \
    -v todo-mysql-data:/var/lib/mysql \
    -e MYSQL_ROOT_PASSWORD=secret \
    -e MYSQL_DATABASE=todos \
    mysql:8.0
*)sudo docker ps
*)sudo docker exec -it e72c65713512 mysql -u root -p:change container id into my id

*)SHOW DATABASES;
*)exit

*)sudo docker run -it --network todo-app nicolaka/netshoot

*)dig mysql

create 2 multicontainers by using windows system:-
-------------------------------------------------
docker network create todo-app
docker pull image
docker run mysql
docker run -e MYSQL_ROOT_PASSWORD=example_pass -d mysql
docker ps
docker inspect (image name)
docker run -it mysql /bin/bash
it will come like this (bash-4.4#)
mysql -h ip-addres  -u root -p(give ip aaddress)
enter password: u can see before u used one command (example _pass)
check SHOWDATABASES;
exit
docker run -it --network todo-app nicolaka/netshoot
dig mysql

what is docker compose:-
----------------------
to create a multicontainers by using yml files
 
create a jenkins pipeline, to connect from local to github repository
create a pipeline to deploy docker on ec2 instance(https://medium.com/@mudasirhaji/set-up-a-cicd-pipeline-using-jenkinsfile-and-docker-on-aws-ec2-555eb56d50c2)

minikubernet install in my local sysytem:-
-----------------------------------------
(run as administrator)
New-Item -Path 'c:\' -Name 'minikube' -ItemType Directory -Force
Invoke-WebRequest -OutFile 'c:\minikube\minikube.exe' -Uri 'https://github.com/kubernetes/minikube/releases/latest/download/minikube-windows-amd64.exe' -UseBasicParsing

$oldPath = [Environment]::GetEnvironmentVariable('Path', [EnvironmentVariableTarget]::Machine)
if ($oldPath.Split(';') -inotcontains 'C:\minikube'){
  [Environment]::SetEnvironmentVariable('Path', $('{0};C:\minikube' -f $oldPath), [EnvironmentVariableTarget]::Machine)
}

minikube start

kubectl get po -A

kubectl get pods -A

kubectl get nodes

kubectl get name space

kubernetes master:-
----------------------
API server:-It is an apllication programming interface
It validates and configures data for the api objects which include pods, services, replication controllers, and others. 
The API Server services REST operations and provides the frontend to the cluster's shared state through which all other components interact.

scheduler:-
---------
kubernetes scheduler is a control plane process which agains pods to nodes.
The scheduler determines which Nodes are valid placements for each Pod in the scheduling queue according to constraints and available resources.
The scheduler then ranks each valid node and binds the pod to a suitable node.

controller-manager:-
------------------
The Kubernetes controller manager is a daemon that embeds the core control loops shipped with Kubernetes.
In applications of robotics and automation, a control loop is a non-terminating loop that regulates the state of the system.

Etcd:-
------
etcd is a consistent and highly-available key value store used as Kubernetes backing store for all cluster data. 
If your Kubernetes cluster uses etcd as its backing store, make sure you have a back up plan for those data. You can find in-depth information about etcd in the official documentation.

kubelet:-
---------
Kubelet is an agent which runs on each node in a Kubernetes cluster. 
It is responsible for all the communications between the Kubernetes control plane and the nodes where the actual workload runs. 
The kubelet takes a set of PodSpecs that are provided through various mechanisms and ensures that the containers described in those PodSpecs are running and healthy.

kube proxy:-
----------
Kube-Proxy is a Kubernetes agent installed on every node in the cluster. 
It monitors the changes that happen to Service objects and their endpoints. 
If changes occur, it translates them into actual network rules inside the node. Kube-Proxy usually runs in your cluster in the form of a DaemonSet.

Basic Commands for create nginx and mongo servers:
--------------------------------------------------
   minikube start
   kubectl get pods -A
   minikube status
   kubectl version
   kubectl get nodes
   kubectl get pod
   kubectl get services
   kubectl create -h
   kubectl create deployment nginx-depl --image=nginx
   kubectl get deployment
   kubectl get pods
   kubectl get replicaset
   kubectl edit deployment nginx-depl
   kubectl get deployment
   kubectl get pods -A
   kubectl get pod
   kubectl create deployment mongo-depl --image=mongo
   kubectl get pod
   kubectl logs mongo-depl-79585f75cf-k6vcf
   kubectl get pod
   kubectl describe pod mongo-depl-79585f75cf-k6vcf
   kubectl exec -it mongo-depl-79585f75cf-k6vcf -- bin/bash
   Exit

How to deploy an application and Create hello-minikube html image:-
------------------------------------------------------------------
kubectl create deployment hello-minikube --image=kicbase/echo-server:1.0
kubectl expose deployment hello-minikube --type=NodePort --port=8080
kubectl get services hello-minikube
minikube service hello-minikube

another way:-
------------
kubectl port-forward service/hello-minikube 7080:8080
http://localhost:7080/

create a load balancer and deployment in minikube and create minikube dashboard:-
--------------------------------------------------------------------------------
kubectl create deployment balanced --image=kicbase/echo-server:1.0
kubectl expose deployment balanced --type=LoadBalancer --port=8080
minikube tunnel
(open another poweshell window)kubectl get services balanced
external-ip:8080

minikube dashboard

(open another poweshell window)minikube dashboard --url


nginx minikube 
---------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx:1.14.2
          ports:
          - containerPort: 80

kubectl describe pod name -n namespace
kubectl apply -f filename

connect one server to another server in shell scripting:
---------------------------------------------------------
*)create 2 new ec2 instances in AWS
*)connect to powershell with ssh pem key
*)create nano file and copy pem document and save the file
*)give permision to the file (chmod 600 keypair)
*)give command ssh -i keypair ec2-user@ 172.31.11.200

network layers:
---------------
1. phyical layer:
 The physical layer is the only layer of the OSI network model that deals with the
 physical connectivity of two different stations.
 It defines the hardware equipment, cabling, wiring, frequencies, and pulses used to represent binary signals
example:Universal Serial Bus (USB), Bluetooth

2.data link layer:
                   Breaking data into frames: Breaking data received from the network layer into smaller units called frames

        The data link layer is the protocol layer that transfers data between nodes on a network segment across the physical layer. 
It is also responsible for the node-to-node delivery of data
example : Ethernet, the IEEE 802.11 WiFi protocols, ATM 

3.network layer:
The network layer's primary function is to enable different networks to be interconnected.  
Managing and selecting the best logical path for data transfer between nodes
Managing sub-networks
Internetworking
Routing packets from source to destination within or outside a subnet
Handling service requests from the transport layer and forwarding the service request to the data link layer
Translating logical addresses into physical addresses
The network layer is also responsible for maintaining the network's traffic in the channel

exapmle:  Internet Protocol (IP): The standard for routing packets across interconnected networks
4.transport layer:
                     The transport layer's main role is to provide communication services directly to the application processes running on different hosts. 
It provides a logical communication between application processes running on different hosts. 
The transport layer provides end-to-end communication services for applications. 
It controls the reliability of a given link through flow control, segmentation and de-segmentation, and error control. 
The transport layer collects message segments from applications, and transmits them into the network 
example  : TCP

5.session layer: 
The session layer works as a dialog controller. It allows systems to communicate in either half-duplex or full-duplex mode of communication. 
 A single session is all the back-and-forth communication between two endpoints. It helps a protocol to be more consistent and reliable. 
The session layer provides the mechanism for opening, closing, and managing a session between end-user application processes. A session is a semi-permanent dialogue
 example :Structured query language (SQL):
Remote procedure call (RPC)
Network file system (NFS)
X window system
DNS

6.presentation layer: 
The presentation layer in a computer network is responsible for formatting and 
converting data so that it is presentable for one application through the network to another application. 
The presentation layer ensures that the information that the application layer of one system sends out is readable by the application layer of another system
example:HTTP/ HTML

7.application layer: 
The application layer is an abstraction layer in a computer network that specifies the shared communications protocols and interface methods used by hosts. It is the layer closest to the end-user,implying that the application layer and the end-user can interact directly with the software application
example :Hypertext Transfer Protocol (HTTP), File Transfer Protocol (FTP)
Simple Mail Transfer Protocol (SMTP), and Domain Name System (DNS). 


create vpc,subnet,igw,sg,route table along with Ec2 using terraform:
------------------------------------------------------------------- 

[0:53 pm, 09/11/2023] Ram: provider "aws" {
  region = "us-east-1"
}

#create vpc
resource "aws_vpc" "my_vpc" {
  cidr_block = "10.0.0.0/16"
  tags = {
   name= var.name
  }
}

#create subnet
resource "aws_subnet" "my_subnet" {
  cidr_block = "10.0.0.0/24"
  vpc_id = aws_vpc.my_vpc.id
  availability_zone = "us-east-1a"
  tags = {
    name = "my_subnet"
  }
}

#create gateway
resource "aws_internet_gateway" "my_gw"{
  vpc_id = aws_vpc.my_vpc.id

  tags ={
    name = "my_gw"
  }
}

# Creating Route Table for Public Subnet
resource "aws_route_table" "rt" {
    vpc_id = aws_vpc.my_vpc.id
route {
        cidr_block = "0.0.0.0/0"
        gateway_id = aws_internet_gateway.my_gw.id
    }
tags = {
        Name = "rt"
    }
resource "aws_route_table_association" "rt_associate_public" {
    subnet_id = aws_subnet.my_subnet.id
    route_table_id = aws_route_table.rt.id
}

#create security group
resource "aws_security_group" "sg" {
vpc_id      = aws_vpc.my_vpc.id
  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}


#create an Ec2 instance
resource "aws_instance" "ec2" {
  ami = "ami-05c13eab67c5d8861"
  instance_type = "t2.micro"
  tags = {
    name = "ec2"
  }
}



 variable "name" {
  description = "the name of vpc"
  type = string
  default = "dev_vpc"
}


 terraform {
  required_providers {
    aws = {
        source = "hashicorp/aws"
        version = "3.19.0"
    }
  }
}








